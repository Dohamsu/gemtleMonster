import { useEffect, useRef, useCallback, useState } from 'react'
import { useGameStore } from '../store/useGameStore'
import { useAlchemyStore } from '../store/useAlchemyStore'
import { useAuth } from '../hooks/useAuth'
import { AlchemyResultModal } from '../ui/alchemy/AlchemyResultModal'
import { ALCHEMY, UI } from '../constants/game'

export default function GameCanvas() {
    const canvasRef = useRef<HTMLCanvasElement>(null)
    const { user } = useAuth()
    const { facilities, canvasView, setCanvasView } = useGameStore()
    const {
        allRecipes,
        allMaterials,
        playerMaterials,
        selectedRecipeId,
        selectedIngredients,
        isBrewing,
        brewStartTime,
        selectRecipe,
        addIngredient,
        removeIngredient,
        startBrewing,
        completeBrewing,
        autoFillIngredients,
        loadAllData,
        playerAlchemy,
        brewResult
    } = useAlchemyStore()

    const [showResultModal, setShowResultModal] = useState(false)
    const [lastBrewResult, setLastBrewResult] = useState<{ success: boolean, monsterId?: string }>({ success: false })

    // Material grid UI state
    const [materialScrollOffset, setMaterialScrollOffset] = useState(0)




    // Show modal when brewing completes
    useEffect(() => {
        if (brewResult.type !== 'idle') {
            setLastBrewResult({
                success: brewResult.type === 'success',
                monsterId: brewResult.monsterId
            })
            setShowResultModal(true)
        }
    }, [brewResult])

    // Load alchemy data on mount
    useEffect(() => {
        if (user) {
            loadAllData(user.id)
        }
    }, [user, loadAllData])

    const imagesRef = useRef<{
        background: HTMLImageElement | null
        herb_farm: HTMLImageElement | null
        mine: HTMLImageElement | null
        alchemy_workshop: HTMLImageElement | null
        cauldron_pixel: HTMLImageElement | null
    }>({
        background: null,
        herb_farm: null,
        mine: null,
        alchemy_workshop: null,
        cauldron_pixel: null
    })

    useEffect(() => {
        const loadImage = (src: string) => {
            return new Promise<HTMLImageElement>((resolve, reject) => {
                const img = new Image()
                img.src = src
                img.onload = () => resolve(img)
                img.onerror = reject
            })
        }
        Promise.all([
            loadImage('/assets/background.png'),
            loadImage('/assets/herb_farm.png'),
            loadImage('/assets/mine.png'),
            loadImage('/assets/alchemy_workshop.png'),
            loadImage('/assets/cauldron_pixel.png')
        ]).then(([bg, herbFarm, mine, alchemyWorkshop, cauldronPixel]) => {
            imagesRef.current = {
                background: bg,
                herb_farm: herbFarm,
                mine: mine,
                alchemy_workshop: alchemyWorkshop,
                cauldron_pixel: cauldronPixel
            }
        }).catch(err => console.error('Failed to load images:', err))
    }, [])

    // Add wheel event listener with passive: false to allow preventDefault
    useEffect(() => {
        const canvas = canvasRef.current
        if (!canvas) return

        const handleWheel = (event: WheelEvent) => {
            if (canvasView !== 'alchemy_workshop') return

            const rect = canvas.getBoundingClientRect()
            const scaleX = canvas.width / rect.width
            const x = (event.clientX - rect.left) * scaleX

            // Check if mouse is over material grid area
            const gridX = canvas.width - 260
            const gridW = 220

            if (x >= gridX && x <= gridX + gridW) {
                event.preventDefault()
                setMaterialScrollOffset(prev => Math.max(0, prev + event.deltaY * UI.SCROLL_SENSITIVITY))
            }
        }

        canvas.addEventListener('wheel', handleWheel, { passive: false })
        return () => canvas.removeEventListener('wheel', handleWheel)
    }, [canvasView])

    const handleCanvasClick = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {
        const canvas = canvasRef.current
        if (!canvas) return
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        const x = (event.clientX - rect.left) * scaleX
        const y = (event.clientY - rect.top) * scaleY

        if (canvasView === 'map') {
            // Check if clicking on alchemy workshop
            const workshopX = canvas.width * 0.5 - 64
            const workshopY = canvas.height * 0.7 - 64
            if (x >= workshopX && x <= workshopX + 128 &&
                y >= workshopY && y <= workshopY + 128) {
                setCanvasView('alchemy_workshop')
            }
        } else if (canvasView === 'alchemy_workshop') {
            // Back button
            const backBtnX = 20
            const backBtnY = 20
            const backBtnW = 100
            const backBtnH = 40
            if (x >= backBtnX && x <= backBtnX + backBtnW &&
                y >= backBtnY && y <= backBtnY + backBtnH) {
                setCanvasView('map')
                return
            }

            // Recipe list clicks
            const recipeX = 40
            const recipeY = 120
            const recipeW = 220

            const visibleRecipes = allRecipes.filter(r => !r.is_hidden)
            let currentY = recipeY + 40
            const recipePadding = 5

            for (let i = 0; i < visibleRecipes.length; i++) {
                const recipe = visibleRecipes[i]
                // Dynamic height: Title(20) + Ingredients(15 * count) + Padding(10)
                const itemHeight = 30 + (recipe.ingredients?.length || 0) * 15 + 10

                if (x >= recipeX && x <= recipeX + recipeW &&
                    y >= currentY && y <= currentY + itemHeight) {
                    // Prevent recipe selection during brewing
                    if (isBrewing) {
                        console.log('Cannot select recipe while brewing')
                        return
                    }
                    selectRecipe(recipe.id)
                    autoFillIngredients(recipe.id)
                    console.log('Selected recipe:', recipe.name)
                    return
                }
                currentY += itemHeight + recipePadding
            }

            // Material grid clicks (right side)
            const gridX = canvas.width - 260
            const gridY = 120
            const gridW = 220
            const gridCellSize = 50
            const gridPadding = 5
            const gridCols = Math.floor(gridW / (gridCellSize + gridPadding))

            // Grid area click detection
            if (x >= gridX && x <= gridX + gridW &&
                y >= gridY + 40 && y <= gridY + canvas.height - 160) {
                const relX = x - gridX
                const relY = y - (gridY + 40) + materialScrollOffset

                const col = Math.floor(relX / (gridCellSize + gridPadding))
                const row = Math.floor(relY / (gridCellSize + gridPadding))
                const index = row * gridCols + col

                if (index >= 0 && index < allMaterials.length) {
                    // Prevent material selection during brewing
                    if (isBrewing) {
                        console.log('Cannot select materials while brewing')
                        return
                    }

                    const material = allMaterials[index]
                    const available = playerMaterials[material.id] || 0
                    const currentlySelected = selectedIngredients[material.id] || 0

                    // If already selected, remove it completely (toggle off)
                    if (currentlySelected > 0) {
                        removeIngredient(material.id, currentlySelected)
                        console.log('Removed ingredient completely:', material.name)
                        return
                    }

                    // Check if material has stock
                    if (available > 0) {
                        // Count total selected ingredients
                        const totalSelected = Object.values(selectedIngredients).reduce((sum, qty) => sum + qty, 0)

                        // Only add if under max limit
                        if (totalSelected < ALCHEMY.MAX_INGREDIENT_SLOTS) {
                            addIngredient(material.id, 1)
                            console.log('Added ingredient:', material.name)
                        } else {
                            console.log('Cannot add more ingredients: maximum', ALCHEMY.MAX_INGREDIENT_SLOTS, 'reached')
                        }
                    } else {
                        console.log('Cannot add material with zero stock:', material.name)
                    }
                    return
                }
            }

            // Ingredient slot clicks (remove ingredients)
            // Prevent slot interaction during brewing
            if (!isBrewing) {
                const cauldronSize = 120
                const cauldronY = 100
                const slotSize = 60
                const slotGap = 10
                const totalSlotsWidth = (slotSize * ALCHEMY.MAX_INGREDIENT_SLOTS) + (slotGap * (ALCHEMY.MAX_INGREDIENT_SLOTS - 1))
                const slotsX = canvas.width / 2 - totalSlotsWidth / 2
                const slotsY = cauldronY + cauldronSize + 20

                const ingredientEntries = Object.entries(selectedIngredients)
                for (let i = 0; i < ALCHEMY.MAX_INGREDIENT_SLOTS && i < ingredientEntries.length; i++) {
                    const slotX = slotsX + i * (slotSize + slotGap)

                    if (x >= slotX && x <= slotX + slotSize &&
                        y >= slotsY && y <= slotsY + slotSize) {
                        const [materialId, quantity] = ingredientEntries[i]
                        removeIngredient(materialId, quantity)
                        const material = allMaterials.find(m => m.id === materialId)
                        console.log('Removed ingredient completely from slot:', material?.name || materialId)
                        return
                    }
                }
            }

            // Brew button
            if (!isBrewing) {
                const brewBtnW = 180
                const brewBtnH = 50
                const brewBtnX = canvas.width / 2 - brewBtnW / 2
                const brewBtnY = canvas.height - 140
                if (x >= brewBtnX && x <= brewBtnX + brewBtnW &&
                    y >= brewBtnY && y <= brewBtnY + brewBtnH) {
                    if (selectedRecipeId) {
                        const recipe = allRecipes.find(r => r.id === selectedRecipeId)
                        if (recipe && recipe.ingredients) {
                            // Check if we have enough materials in inventory
                            const hasMaterials = recipe.ingredients.every(ing =>
                                (playerMaterials[ing.material_id] || 0) >= ing.quantity
                            )
                            // Check alchemy level
                            const hasLevel = (playerAlchemy?.level || 1) >= recipe.required_alchemy_level

                            if (hasMaterials && hasLevel) {
                                // Must fill ingredients into selectedIngredients for startBrewing to work
                                autoFillIngredients(selectedRecipeId)
                                startBrewing(selectedRecipeId)
                                console.log('üß™ Brewing started!')

                                // Auto-complete after craftTime
                                // Note: This timer should ideally be tracked in useRef for cleanup
                                setTimeout(() => {
                                    const success = Math.random() * 100 < recipe.base_success_rate
                                    completeBrewing(success)
                                    console.log(success ? '‚úÖ Brewing success!' : '‚ùå Brewing failed!')
                                }, recipe.craft_time_sec * 1000)
                            } else {
                                if (!hasMaterials) console.log('‚ùå Not enough materials in inventory!')
                                if (!hasLevel) console.log(`‚ùå Alchemy level too low! Required: ${recipe.required_alchemy_level}`)
                            }
                        }
                    }
                }
            }
        }
    }, [canvasView, setCanvasView, allRecipes, allMaterials, playerMaterials, selectedRecipeId, selectedIngredients, isBrewing, selectRecipe, addIngredient, startBrewing, completeBrewing])

    useEffect(() => {
        const canvas = canvasRef.current
        if (!canvas) return
        const ctx = canvas.getContext('2d')
        if (!ctx) return
        let animationFrameId: number

        const render = () => {
            if (canvas.width !== canvas.parentElement?.clientWidth || canvas.height !== canvas.parentElement?.clientHeight) {
                canvas.width = canvas.parentElement?.clientWidth || 800
                canvas.height = canvas.parentElement?.clientHeight || 600
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            const imgs = imagesRef.current

            if (canvasView === 'map') {
                // Render Map View
                ctx.fillStyle = '#000000'
                ctx.fillRect(0, 0, canvas.width, canvas.height)
                if (imgs.herb_farm && facilities['herb_farm']) {
                    const farmX = canvas.width * 0.3 - 64
                    const farmY = canvas.height * 0.4 - 64
                    ctx.drawImage(imgs.herb_farm, farmX, farmY, 128, 128)
                    ctx.fillStyle = 'white'
                    ctx.font = 'bold 14px Arial'
                    ctx.shadowColor = 'black'
                    ctx.shadowBlur = 4
                    ctx.fillText(`Lv.${facilities['herb_farm']} `, farmX + 30, farmY + 140)
                    ctx.shadowBlur = 0
                }
                if (imgs.mine && facilities['mine'] && facilities['mine'] > 0) {
                    const mineX = canvas.width * 0.7 - 64
                    const mineY = canvas.height * 0.4 - 64
                    ctx.drawImage(imgs.mine, mineX, mineY, 128, 128)
                    ctx.fillStyle = 'white'
                    ctx.font = 'bold 14px Arial'
                    ctx.shadowColor = 'black'
                    ctx.shadowBlur = 4
                    ctx.fillText(`Lv.${facilities['mine']} `, mineX + 30, mineY + 140)
                    ctx.shadowBlur = 0
                }
                if (imgs.alchemy_workshop) {
                    const workshopX = canvas.width * 0.5 - 64
                    const workshopY = canvas.height * 0.7 - 64
                    ctx.drawImage(imgs.alchemy_workshop, workshopX, workshopY, 128, 128)
                    ctx.fillStyle = 'white'
                    ctx.font = 'bold 14px Arial'
                    ctx.shadowColor = 'black'
                    ctx.shadowBlur = 4
                    ctx.fillText('Ïó∞Í∏àÏà† Í≥µÎ∞©', workshopX + 20, workshopY + 140)
                    ctx.shadowBlur = 0
                }
            } else if (canvasView === 'alchemy_workshop') {
                // Render Alchemy Workshop Interior
                ctx.fillStyle = '#2a1810'
                ctx.fillRect(0, 0, canvas.width, canvas.height)

                // Back button
                const backBtnX = 20
                const backBtnY = 20
                const backBtnW = 100
                const backBtnH = 40
                ctx.fillStyle = '#4a3020'
                ctx.fillRect(backBtnX, backBtnY, backBtnW, backBtnH)
                ctx.strokeStyle = '#8a6040'
                ctx.lineWidth = 2
                ctx.strokeRect(backBtnX, backBtnY, backBtnW, backBtnH)
                ctx.fillStyle = 'white'
                ctx.font = 'bold 16px Arial'
                ctx.textAlign = 'center'
                ctx.textBaseline = 'middle'
                ctx.fillText('‚Üê ÎèåÏïÑÍ∞ÄÍ∏∞', backBtnX + backBtnW / 2, backBtnY + backBtnH / 2)

                // Title
                ctx.fillStyle = '#f0d090'
                ctx.font = 'bold 32px Arial'
                ctx.textAlign = 'center'
                ctx.fillText('üß™ Ïó∞Í∏àÏà† Í≥µÎ∞©', canvas.width / 2, 60)

                // Central Cauldron Area
                const cauldronX = canvas.width / 2 - 100
                const cauldronY = canvas.height / 2 - 100
                const cauldronSize = 200

                ctx.fillStyle = '#1a1410'
                ctx.beginPath()
                ctx.arc(cauldronX + cauldronSize / 2, cauldronY + cauldronSize / 2, cauldronSize / 2, 0, Math.PI * 2)
                ctx.fill()

                ctx.strokeStyle = '#6a4020'
                ctx.lineWidth = 4
                ctx.stroke()

                if (imgs.cauldron_pixel) {
                    const imgSize = 128
                    ctx.drawImage(imgs.cauldron_pixel,
                        cauldronX + cauldronSize / 2 - imgSize / 2,
                        cauldronY + cauldronSize / 2 - imgSize / 2,
                        imgSize, imgSize
                    )
                } else {
                    ctx.font = 'bold 80px Arial'
                    ctx.textAlign = 'center'
                    ctx.textBaseline = 'middle'
                    ctx.fillText('üçØ', cauldronX + cauldronSize / 2, cauldronY + cauldronSize / 2)
                }

                // Ingredient Slots (below cauldron)
                const slotSize = 60
                const slotGap = 10
                const totalSlotsWidth = (slotSize * ALCHEMY.MAX_INGREDIENT_SLOTS) + (slotGap * (ALCHEMY.MAX_INGREDIENT_SLOTS - 1))
                const slotsX = canvas.width / 2 - totalSlotsWidth / 2
                const slotsY = cauldronY + cauldronSize + 20

                // Get selected ingredients and required amounts from the selected recipe
                const selectedRecipe = allRecipes.find(r => r.id === selectedRecipeId)
                const requiredMap: Record<string, number> = {}
                if (selectedRecipe && selectedRecipe.ingredients) {
                    selectedRecipe.ingredients.forEach(ing => {
                        requiredMap[ing.material_id] = ing.quantity
                    })
                }
                const ingredientEntries = Object.entries(selectedIngredients)

                for (let i = 0; i < ALCHEMY.MAX_INGREDIENT_SLOTS; i++) {
                    const slotX = slotsX + i * (slotSize + slotGap)

                    // Draw slot background
                    ctx.fillStyle = '#2a2520'
                    ctx.fillRect(slotX, slotsY, slotSize, slotSize)
                    ctx.strokeStyle = '#7a5040'
                    ctx.lineWidth = 2
                    ctx.strokeRect(slotX, slotsY, slotSize, slotSize)

                    // If slot has ingredient, render it
                    if (i < ingredientEntries.length) {
                        const [materialId, quantity] = ingredientEntries[i]
                        const material = allMaterials.find(m => m.id === materialId)

                        if (material) {
                            // Draw material icon
                            ctx.fillStyle = '#f0d090'
                            ctx.font = '32px Arial'
                            ctx.textAlign = 'center'
                            ctx.textBaseline = 'middle'
                            const iconMap: Record<string, string> = {
                                'PLANT': 'üåø',
                                'MINERAL': 'üíé',
                                'BEAST': 'ü¶¥',
                                'SLIME': 'üü¢',
                                'SPIRIT': '‚ú®'
                            }
                            ctx.fillText(iconMap[material.family] || '‚ùì', slotX + slotSize / 2, slotsY + slotSize / 2 - 5)

                            // Draw quantity (selected amount)
                            ctx.fillStyle = '#1a1a1a'
                            ctx.fillRect(slotX + slotSize - 18, slotsY + slotSize - 14, 16, 12)
                            ctx.fillStyle = '#facc15'
                            ctx.font = 'bold 9px Arial'
                            ctx.fillText(quantity.toString(), slotX + slotSize - 10, slotsY + slotSize - 6)

                            // If insufficient for required amount, overlay red required number
                            const requiredQty = requiredMap[materialId] || 0
                            if (quantity < requiredQty) {
                                ctx.fillStyle = 'rgba(255,0,0,0.6)'
                                ctx.fillRect(slotX, slotsY, slotSize, slotSize)
                                ctx.fillStyle = '#fff'
                                ctx.font = 'bold 12px Arial'
                                ctx.fillText(`${quantity}/${requiredQty}`, slotX + slotSize / 2, slotsY + slotSize / 2)
                            }
                        }
                    } else {
                        // Empty slot indicator
                        ctx.fillStyle = '#666'
                        ctx.font = '24px Arial'
                        ctx.textAlign = 'center'
                        ctx.textBaseline = 'middle'
                        ctx.fillText('+', slotX + slotSize / 2, slotsY + slotSize / 2)
                    }
                }

                // Recipe List (Left Side)
                const recipeX = 40
                const recipeY = 120
                const recipeW = 220
                const recipeH = canvas.height - 160

                ctx.fillStyle = '#3a2520'
                ctx.fillRect(recipeX, recipeY, recipeW, recipeH)
                ctx.strokeStyle = '#7a5040'
                ctx.lineWidth = 2
                ctx.strokeRect(recipeX, recipeY, recipeW, recipeH)

                ctx.fillStyle = '#f0d090'
                ctx.font = 'bold 18px Arial'
                ctx.textAlign = 'left'
                ctx.textBaseline = 'top'
                ctx.fillText('üìú Î†àÏãúÌîº', recipeX + 10, recipeY + 10)

                // Render recipe items
                const visibleRecipes = allRecipes.filter(r => !r.is_hidden)
                const recipePadding = 5
                let currentY = recipeY + 40

                // Dim entire recipe list if brewing
                if (isBrewing) {
                    ctx.globalAlpha = 0.4
                }

                visibleRecipes.forEach((recipe) => {
                    const itemHeight = 30 + (recipe.ingredients?.length || 0) * 15 + 10
                    const itemY = currentY
                    const isSelected = selectedRecipeId === recipe.id

                    // Check materials for dimming
                    const hasAllMaterials = recipe.ingredients?.every(ing =>
                        (playerMaterials[ing.material_id] || 0) >= ing.quantity
                    ) ?? true

                    // Apply dimming if insufficient materials
                    if (!hasAllMaterials) {
                        ctx.globalAlpha = 0.5
                    }

                    ctx.fillStyle = isSelected ? '#5a4030' : '#4a3020'
                    ctx.fillRect(recipeX + 5, itemY, recipeW - 10, itemHeight)

                    if (isSelected) {
                        ctx.strokeStyle = '#facc15'
                        ctx.lineWidth = 2
                        ctx.strokeRect(recipeX + 5, itemY, recipeW - 10, itemHeight)
                    }

                    ctx.fillStyle = '#f0d090'
                    ctx.font = 'bold 14px Arial'
                    ctx.fillText(`${recipe.name} (${recipe.craft_time_sec}s)`, recipeX + 10, itemY + 8)

                    // Materials required
                    if (recipe.ingredients) {
                        recipe.ingredients.forEach((ing, idx) => {
                            const mat = allMaterials.find(m => m.id === ing.material_id)
                            const owned = playerMaterials[ing.material_id] || 0
                            const hasEnough = owned >= ing.quantity
                            const yPos = itemY + 28 + (idx * 15)

                            ctx.fillStyle = hasEnough ? '#aaa' : '#ff6666'
                            ctx.font = '11px Arial'
                            ctx.fillText(`${mat?.name || ing.material_id} ${owned}/${ing.quantity}`, recipeX + 10, yPos, recipeW - 20)
                        })
                    }

                    // Reset alpha (but maintain brewing dimming)
                    if (!isBrewing) {
                        ctx.globalAlpha = 1.0
                    }

                    currentY += itemHeight + recipePadding
                })

                // Reset alpha after recipe list
                ctx.globalAlpha = 1.0

                // Inventory (Right Side)
                const invX = canvas.width - 260
                const invY = 120
                const invW = 220
                const invH = canvas.height - 160

                ctx.fillStyle = '#3a2520'
                ctx.fillRect(invX, invY, invW, invH)
                ctx.strokeStyle = '#7a5040'
                ctx.lineWidth = 2
                ctx.strokeRect(invX, invY, invW, invH)

                ctx.fillStyle = '#f0d090'
                ctx.font = 'bold 18px Arial'
                ctx.textAlign = 'left'
                ctx.fillText('üéí Î≥¥Ïú† Ïû¨Î£å', invX + 10, invY + 10)

                // Material grid with scrolling
                const gridCellSize = UI.MATERIAL_CELL_SIZE
                const gridPadding = UI.MATERIAL_GRID_PADDING
                const gridCols = Math.floor(invW / (gridCellSize + gridPadding))

                // Dim entire material grid if brewing
                if (isBrewing) {
                    ctx.globalAlpha = 0.4
                }

                // Helper function for rarity colors
                const getRarityColor = (rarity: string) => {
                    switch (rarity.toUpperCase()) {
                        case 'COMMON': return '#9ca3af'
                        case 'UNCOMMON': return '#22c55e'
                        case 'RARE': return '#3b82f6'
                        case 'EPIC': return '#a855f7'
                        case 'LEGENDARY': return '#eab308'
                        default: return '#9ca3af'
                    }
                }

                // Save canvas state and setup clipping region
                ctx.save()
                ctx.beginPath()
                ctx.rect(invX, invY, invW, invH)
                ctx.clip()

                // Render material grid
                let gridStartY = invY + 40 - materialScrollOffset
                allMaterials.forEach((material, index) => {
                    const col = index % gridCols
                    const row = Math.floor(index / gridCols)

                    const cellX = invX + col * (gridCellSize + gridPadding) + gridPadding
                    const cellY = gridStartY + row * (gridCellSize + gridPadding) + gridPadding

                    // Only render if in visible area
                    if (cellY + gridCellSize < invY + 40 || cellY > invY + invH) return

                    const count = playerMaterials[material.id] || 0
                    const rarityColor = getRarityColor(material.rarity)

                    // Dim if no stock
                    ctx.globalAlpha = count > 0 ? 1 : 0.3

                    // Draw cell background
                    ctx.fillStyle = '#2a2520'
                    ctx.fillRect(cellX, cellY, gridCellSize, gridCellSize)

                    // Check if material is selected
                    const isSelected = selectedIngredients[material.id] > 0

                    // Draw border (highlighted if selected)
                    ctx.lineWidth = isSelected ? 4 : 2
                    ctx.strokeStyle = isSelected ? '#fbbf24' : rarityColor
                    ctx.strokeRect(cellX, cellY, gridCellSize, gridCellSize)

                    // Draw material icon (placeholder - will use actual icons later)
                    ctx.fillStyle = '#f0d090'
                    ctx.font = '24px Arial'
                    ctx.textAlign = 'center'
                    ctx.textBaseline = 'middle'
                    const iconMap: Record<string, string> = {
                        'PLANT': 'üåø',
                        'MINERAL': 'üíé',
                        'BEAST': 'ü¶¥',
                        'SLIME': 'üü¢',
                        'SPIRIT': '‚ú®'
                    }
                    ctx.fillText(iconMap[material.family] || '‚ùì', cellX + gridCellSize / 2, cellY + gridCellSize / 2 - 5)

                    // Draw quantity badge (top-right corner)
                    if (count > 0) {
                        ctx.fillStyle = '#1a1a1a'
                        ctx.fillRect(cellX + gridCellSize - 18, cellY + 2, 16, 12)

                        ctx.fillStyle = '#facc15'
                        ctx.font = 'bold 9px Arial'
                        ctx.textAlign = 'center'
                        ctx.fillText(count.toString(), cellX + gridCellSize - 10, cellY + 10)
                    }

                    // Draw material name below icon
                    ctx.fillStyle = '#f0d090'
                    ctx.font = '9px Arial'
                    ctx.textAlign = 'center'
                    ctx.textBaseline = 'bottom'
                    const displayName = material.name.length > 8 ? material.name.substring(0, 7) + '...' : material.name
                    ctx.fillText(displayName, cellX + gridCellSize / 2, cellY + gridCellSize - 2)

                    // Reset alpha for subsequent drawing (maintain brewing dimming if active)
                    ctx.globalAlpha = isBrewing ? 0.4 : 1
                })

                // Restore canvas state (remove clipping)
                ctx.restore()

                // Reset alpha after material grid
                ctx.globalAlpha = 1.0



                // Brew Button
                const brewBtnW = 180
                const brewBtnH = 50
                const brewBtnX = canvas.width / 2 - brewBtnW / 2
                const brewBtnY = canvas.height - 140 // Moved higher to make room for XP bar

                if (isBrewing) {
                    // Progress bar
                    ctx.fillStyle = '#3a2a20'
                    ctx.fillRect(brewBtnX, brewBtnY, brewBtnW, brewBtnH)
                    ctx.strokeStyle = '#7a5a40'
                    ctx.lineWidth = 3
                    ctx.strokeRect(brewBtnX, brewBtnY, brewBtnW, brewBtnH)

                    const selectedRecipe = allRecipes.find(r => r.id === selectedRecipeId)
                    if (selectedRecipe && brewStartTime) {
                        const elapsed = Date.now() - brewStartTime
                        const progress = Math.min(elapsed / (selectedRecipe.craft_time_sec * 1000), 1)

                        const progressW = (brewBtnW - 10) * progress
                        ctx.fillStyle = '#facc15'
                        ctx.fillRect(brewBtnX + 5, brewBtnY + 5, progressW, brewBtnH - 10)

                        ctx.fillStyle = '#fff'
                        ctx.font = 'bold 18px Arial'
                        ctx.textAlign = 'center'
                        ctx.textBaseline = 'middle'
                        ctx.fillText(`‚öóÔ∏è Ï†úÏ°∞ Ï§ë... ${Math.floor(progress * 100)}%`, brewBtnX + brewBtnW / 2, brewBtnY + brewBtnH / 2)
                    }
                } else {
                    const canBrew = selectedRecipeId !== null
                    const selectedRecipe = allRecipes.find(r => r.id === selectedRecipeId)
                    let hasMaterials = false
                    let hasLevel = false

                    if (selectedRecipe && selectedRecipe.ingredients) {
                        hasMaterials = selectedRecipe.ingredients.every(ing =>
                            (playerMaterials[ing.material_id] || 0) >= ing.quantity
                        )
                        hasLevel = (playerAlchemy?.level || 1) >= selectedRecipe.required_alchemy_level
                    }

                    const isEnabled = canBrew && hasMaterials && hasLevel

                    ctx.fillStyle = isEnabled ? '#5a3a20' : '#3a2520'
                    ctx.fillRect(brewBtnX, brewBtnY, brewBtnW, brewBtnH)
                    ctx.strokeStyle = isEnabled ? '#9a6a40' : '#5a4030'
                    ctx.lineWidth = 3
                    ctx.strokeRect(brewBtnX, brewBtnY, brewBtnW, brewBtnH)

                    ctx.fillStyle = isEnabled ? '#f0d090' : '#666'
                    ctx.font = 'bold 20px Arial'
                    ctx.textAlign = 'center'
                    ctx.textBaseline = 'middle'

                    let btnText = '‚öóÔ∏è Ïó∞Í∏àÏà† ÏãúÏûë'
                    if (selectedRecipe && !hasLevel) btnText = `Lv.${selectedRecipe.required_alchemy_level} ÌïÑÏöî`
                    else if (selectedRecipe && !hasMaterials) btnText = 'Ïû¨Î£å Î∂ÄÏ°±'

                    ctx.fillText(btnText, brewBtnX + brewBtnW / 2, brewBtnY + brewBtnH / 2)
                }

                // XP Bar (Below Brew Button)
                if (playerAlchemy) {
                    const xpBarY = brewBtnY + brewBtnH + 15
                    const xpBarW = 300
                    const xpBarH = 30
                    const xpBarX = canvas.width / 2 - xpBarW / 2

                    // Background
                    ctx.fillStyle = '#2a1a10'
                    ctx.fillRect(xpBarX, xpBarY, xpBarW, xpBarH)
                    ctx.strokeStyle = '#6a4a30'
                    ctx.lineWidth = 2
                    ctx.strokeRect(xpBarX, xpBarY, xpBarW, xpBarH)

                    // XP Progress
                    const currentLevelExp = playerAlchemy.experience % ALCHEMY.XP_PER_LEVEL
                    const expProgress = currentLevelExp / ALCHEMY.XP_PER_LEVEL
                    const progressWidth = (xpBarW - 6) * expProgress

                    ctx.fillStyle = '#facc15'
                    ctx.fillRect(xpBarX + 3, xpBarY + 3, progressWidth, xpBarH - 6)

                    // Text
                    ctx.fillStyle = '#f0d090'
                    ctx.font = 'bold 14px Arial'
                    ctx.textAlign = 'center'
                    ctx.textBaseline = 'middle'
                    ctx.fillText(
                        `Ïó∞Í∏àÏà† Lv.${playerAlchemy.level} [${currentLevelExp}/${ALCHEMY.XP_PER_LEVEL} XP]`,
                        xpBarX + xpBarW / 2,
                        xpBarY + xpBarH / 2
                    )
                }

                ctx.textAlign = 'left'
                ctx.textBaseline = 'alphabetic'
            }

            animationFrameId = requestAnimationFrame(render)
        }
        render()
        return () => {
            cancelAnimationFrame(animationFrameId)
        }
    }, [facilities, canvasView, allRecipes, allMaterials, playerMaterials, selectedRecipeId, selectedIngredients, isBrewing, brewStartTime, playerAlchemy, materialScrollOffset])

    return (
        <>
            <canvas
                ref={canvasRef}
                onClick={handleCanvasClick}
                style={{ width: '100%', height: '100%', display: 'block', cursor: 'pointer' }}
            />
            <AlchemyResultModal
                isOpen={showResultModal}
                success={lastBrewResult.success}
                monsterId={lastBrewResult.monsterId}
                onClose={() => setShowResultModal(false)}
            />
        </>
    )
}
